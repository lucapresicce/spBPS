arma::mat tX = trans(X);
arma::mat iV_r = arma::inv(V_r);
arma::mat iR_s = arma::inv(Rphi_s);
// Compute posterior updating
arma::mat V_B = a * tX * X + iV_r;
arma::mat V_BW = a * tX;
arma::mat V_WB = trans(V_BW);
arma::mat V_W = iR_s + (a * eye<arma::mat>(n, n));
arma::mat V_star1 = join_horiz(V_B, V_BW);
arma::mat V_star2 = join_horiz(V_WB, V_W);
arma::mat iV_star = join_vert( V_star1, V_star2);
arma::mat V_star = arma::inv(iV_star);
arma::mat M = join_vert( (a * tX * Y) + (iV_r * mu_B) , a * Y );
arma::mat mu_star = V_star * M;
arma::mat aYY = (a * trans(Y) * Y);
arma::mat mbVrmb = (trans(mu_B) * iV_r * mu_B);
arma::mat msVsms = (trans(mu_star) * iV_star * mu_star);
arma::mat Psi_star = Psi + aYY  + mbVrmb - msVsms;
double nu_star = nu + n;
// Return results as an R list
return List::create(Named("V_star") = V_star,
Named("mu_star") = mu_star,
Named("Psi_star") = Psi_star,
Named("nu_star") = nu_star,
Named("iRphi_s") = iR_s);
}
// [[Rcpp::export]]
List fit_cpp_MvT_new(const List& data, const List& priors, const arma::mat& coords, const List& hyperpar) {
// Unpack data and priors
arma::mat Y = as<arma::mat>(data["Y"]);
arma::mat X = as<arma::mat>(data["X"]);
arma::mat mu_B = as<arma::mat>(priors["mu_B"]);
arma::mat V_r = as<arma::mat>(priors["V_r"]);
arma::mat Psi = as<arma::mat>(priors["Psi"]);
double nu = as<double>(priors["nu"]);
double alpha = as<double>(hyperpar["alpha"]);
double phi = as<double>(hyperpar["phi"]);
int n = Y.n_rows;
int p = X.n_cols;
arma::mat d_s = arma_dist(coords);
arma::mat Rphi_s = exp(-phi * d_s);
// Precompute some reusable values
double a = (alpha / (1 - alpha));
arma::mat tX = trans(X);
arma::mat iV_r = arma::inv(V_r);
arma::mat iR_s = arma::inv(Rphi_s);
// arma::mat L_r = trimatu(chol(Rphi_s));
// arma::mat iR_s = solve(L_r, solve(trans(L_r), eye<arma::mat>(n, n), solve_opts::fast), solve_opts::fast);
// Compute posterior updating
arma::mat V_B = a * tX * X + iV_r;
arma::mat V_BW = a * tX;
arma::mat V_WB = trans(V_BW);
arma::mat V_W = iR_s + (a * eye<arma::mat>(n, n));
arma::mat V_star1 = join_horiz(V_B, V_BW);
arma::mat V_star2 = join_horiz(V_WB, V_W);
arma::mat iV_star = join_vert( V_star1, V_star2);
// arma::mat V_star = arma::inv(iV_star);
// arma::mat M = join_vert( (a * tX * Y) + (iV_r * mu_B) , a * Y );
// arma::mat mu_star = V_star * M;
// arma::mat aYY = (a * trans(Y) * Y);
// arma::mat mbVrmb = (trans(mu_B) * iV_r * mu_B);
// arma::mat msVsms = (trans(mu_star) * iV_star * mu_star);
// arma::mat Psi_star = Psi + aYY  + mbVrmb - msVsms;
// double nu_star = nu + n;
arma::mat iL_v = trimatu(chol(iV_star));
arma::mat M = join_vert( (a * tX * Y) + (iV_r * mu_B) , a * Y );
arma::mat u = solve(iL_v, M, solve_opts::fast);
arma::mat mu_star = solve(trans(iL_v), u, solve_opts::fast);
arma::mat V_star = solve(iL_v, solve(trans(iL_v), eye<arma::mat>(n+p, n+p), solve_opts::fast), solve_opts::fast);
arma::mat aYY = (a * trans(Y) * Y);
arma::mat mbVrmb = (trans(mu_B) * iV_r * mu_B);
arma::mat utu = (trans(u) * u);
arma::mat Psi_star = Psi + aYY  + mbVrmb - utu;
double nu_star = nu + n;
// Return results as an R list
return List::create(Named("mu_star") = mu_star,
Named("Psi_star") = Psi_star,
Named("nu_star") = nu_star,
Named("V_star") = V_star,
// Named("iRphi_s") = z);
Named("iRphi_s") = iR_s);
}
'
# compile functions
Rcpp::sourceCpp(code = cd)
fun_old <- function() {
fit_cpp_MvT(data = list(Y = Y, X = X),
priors = list(mu_B = matrix(0, nrow = p, ncol = q),
V_r = diag(10, p),
Psi = diag(1, q),
nu = 3),
coords = crd,
hyperpar = list(alpha = alfa, phi = phi))
return(NULL)
}
fun_new <- function() {
fit_cpp_MvT_new(data = list(Y = Y, X = X),
priors = list(mu_B = matrix(0, nrow = p, ncol = q),
V_r = diag(10, p),
Psi = diag(1, q),
nu = 3),
coords = crd,
hyperpar = list(alpha = alfa, phi = phi))
return(NULL)
}
tictoc::tic()
fun_old()
tictoc::toc()
tictoc::tic()
fun_new()
tictoc::toc()
tictoc::tic()
fun_new()
tictoc::toc()
tictoc::tic()
fun_new()
tictoc::toc()
microbenchmark::microbenchmark(fun_old(), fun_new())
# write function
cd <-
'
#include <RcppArmadillo.h>
// [[Rcpp::depends(RcppArmadillo)]]
using namespace Rcpp;
using namespace arma;
// [[Rcpp::export(name = "arma_dist")]]
arma::mat arma_dist(const arma::mat & X){
int n = X.n_rows;
arma::mat D(n, n, fill::zeros); // Allocate a matrix of dimension n x n
for (int i = 0; i < n; i++) {
for(int k = 0; k < i; k++){
D(i, k) = sqrt(sum(pow(X.row(i) - X.row(k), 2)));
D(k, i) = D(i, k);
}
}
return D;
}
// [[Rcpp::export]]
List fit_cpp_MvT(const List& data, const List& priors, const arma::mat& coords, const List& hyperpar) {
// Unpack data and priors
arma::mat Y = as<arma::mat>(data["Y"]);
arma::mat X = as<arma::mat>(data["X"]);
arma::mat mu_B = as<arma::mat>(priors["mu_B"]);
arma::mat V_r = as<arma::mat>(priors["V_r"]);
arma::mat Psi = as<arma::mat>(priors["Psi"]);
double nu = as<double>(priors["nu"]);
double alpha = as<double>(hyperpar["alpha"]);
double phi = as<double>(hyperpar["phi"]);
int n = Y.n_rows;
arma::mat d_s = arma_dist(coords);
arma::mat Rphi_s = exp(-phi * d_s);
// Precompute some reusable values
double a = (alpha / (1 - alpha));
arma::mat tX = trans(X);
arma::mat iV_r = arma::inv(V_r);
arma::mat iR_s = arma::inv(Rphi_s);
// Compute posterior updating
arma::mat V_B = a * tX * X + iV_r;
arma::mat V_BW = a * tX;
arma::mat V_WB = trans(V_BW);
arma::mat V_W = iR_s + (a * eye<arma::mat>(n, n));
arma::mat V_star1 = join_horiz(V_B, V_BW);
arma::mat V_star2 = join_horiz(V_WB, V_W);
arma::mat iV_star = join_vert( V_star1, V_star2);
arma::mat V_star = arma::inv(iV_star);
arma::mat M = join_vert( (a * tX * Y) + (iV_r * mu_B) , a * Y );
arma::mat mu_star = V_star * M;
arma::mat aYY = (a * trans(Y) * Y);
arma::mat mbVrmb = (trans(mu_B) * iV_r * mu_B);
arma::mat msVsms = (trans(mu_star) * iV_star * mu_star);
arma::mat Psi_star = Psi + aYY  + mbVrmb - msVsms;
double nu_star = nu + n;
// Return results as an R list
return List::create(Named("V_star") = V_star,
Named("mu_star") = mu_star,
Named("Psi_star") = Psi_star,
Named("nu_star") = nu_star,
Named("iRphi_s") = iR_s);
}
// [[Rcpp::export]]
List fit_cpp_MvT_new(const List& data, const List& priors, const arma::mat& coords, const List& hyperpar) {
// Unpack data and priors
arma::mat Y = as<arma::mat>(data["Y"]);
arma::mat X = as<arma::mat>(data["X"]);
arma::mat mu_B = as<arma::mat>(priors["mu_B"]);
arma::mat V_r = as<arma::mat>(priors["V_r"]);
arma::mat Psi = as<arma::mat>(priors["Psi"]);
double nu = as<double>(priors["nu"]);
double alpha = as<double>(hyperpar["alpha"]);
double phi = as<double>(hyperpar["phi"]);
int n = Y.n_rows;
int p = X.n_cols;
arma::mat d_s = arma_dist(coords);
arma::mat Rphi_s = exp(-phi * d_s);
// Precompute some reusable values
double a = (alpha / (1 - alpha));
arma::mat tX = trans(X);
arma::mat iV_r = arma::inv(V_r);
arma::mat iR_s = arma::inv(Rphi_s);
// arma::mat L_r = trimatu(chol(Rphi_s));
// arma::mat iR_s = solve(L_r, solve(trans(L_r), eye<arma::mat>(n, n), solve_opts::fast), solve_opts::fast);
// Compute posterior updating
arma::mat V_B = a * tX * X + iV_r;
arma::mat V_BW = a * tX;
arma::mat V_WB = trans(V_BW);
arma::mat V_W = iR_s + (a * eye<arma::mat>(n, n));
arma::mat V_star1 = join_horiz(V_B, V_BW);
arma::mat V_star2 = join_horiz(V_WB, V_W);
arma::mat iV_star = join_vert( V_star1, V_star2);
// arma::mat V_star = arma::inv(iV_star);
// arma::mat M = join_vert( (a * tX * Y) + (iV_r * mu_B) , a * Y );
// arma::mat mu_star = V_star * M;
// arma::mat aYY = (a * trans(Y) * Y);
// arma::mat mbVrmb = (trans(mu_B) * iV_r * mu_B);
// arma::mat msVsms = (trans(mu_star) * iV_star * mu_star);
// arma::mat Psi_star = Psi + aYY  + mbVrmb - msVsms;
// double nu_star = nu + n;
arma::mat iL_v = inv(trimatu(chol(iV_star)));
arma::mat M = join_vert( (a * tX * Y) + (iV_r * mu_B) , a * Y );
arma::mat u = iL_v * M;
arma::mat mu_star = trans(iL_v) * u;
arma::mat V_star = solve(iL_v, solve(trans(iL_v), eye<arma::mat>(n+p, n+p), solve_opts::fast), solve_opts::fast);
arma::mat aYY = (a * trans(Y) * Y);
arma::mat mbVrmb = (trans(mu_B) * iV_r * mu_B);
arma::mat utu = (trans(u) * u);
arma::mat Psi_star = Psi + aYY  + mbVrmb - utu;
double nu_star = nu + n;
// Return results as an R list
return List::create(Named("mu_star") = mu_star,
Named("Psi_star") = Psi_star,
Named("nu_star") = nu_star,
Named("V_star") = V_star,
// Named("iRphi_s") = z);
Named("iRphi_s") = iR_s);
}
'
# compile functions
Rcpp::sourceCpp(code = cd)
fun_old <- function() {
fit_cpp_MvT(data = list(Y = Y, X = X),
priors = list(mu_B = matrix(0, nrow = p, ncol = q),
V_r = diag(10, p),
Psi = diag(1, q),
nu = 3),
coords = crd,
hyperpar = list(alpha = alfa, phi = phi))
return(NULL)
}
fun_new <- function() {
fit_cpp_MvT_new(data = list(Y = Y, X = X),
priors = list(mu_B = matrix(0, nrow = p, ncol = q),
V_r = diag(10, p),
Psi = diag(1, q),
nu = 3),
coords = crd,
hyperpar = list(alpha = alfa, phi = phi))
return(NULL)
}
tictoc::tic()
fun_old()
tictoc::toc()
tictoc::tic()
fun_new()
tictoc::toc()
microbenchmark::microbenchmark(fun_old(), fun_new())
# write function
cd <-
'
#include <RcppArmadillo.h>
#include <RcppClock.h>
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::depends(RcppClock)]]
using namespace Rcpp;
using namespace arma;
// [[Rcpp::export(name = "arma_dist")]]
arma::mat arma_dist(const arma::mat & X){
int n = X.n_rows;
arma::mat D(n, n, fill::zeros); // Allocate a matrix of dimension n x n
for (int i = 0; i < n; i++) {
for(int k = 0; k < i; k++){
D(i, k) = sqrt(sum(pow(X.row(i) - X.row(k), 2)));
D(k, i) = D(i, k);
}
}
return D;
}
// [[Rcpp::export]]
List fit_cpp_MvT(const List& data, const List& priors, const arma::mat& coords, const List& hyperpar) {
Rcpp::Clock clock; // mind the headers: //[[Rcpp::depends(RcppClock)]] #include <RcppClock.h> #include <thread>
// Unpack data and priors
arma::mat Y = as<arma::mat>(data["Y"]);
arma::mat X = as<arma::mat>(data["X"]);
arma::mat mu_B = as<arma::mat>(priors["mu_B"]);
arma::mat V_r = as<arma::mat>(priors["V_r"]);
arma::mat Psi = as<arma::mat>(priors["Psi"]);
double nu = as<double>(priors["nu"]);
double alpha = as<double>(hyperpar["alpha"]);
double phi = as<double>(hyperpar["phi"]);
int n = Y.n_rows;
arma::mat d_s = arma_dist(coords);
arma::mat Rphi_s = exp(-phi * d_s);
// Precompute some reusable values
double a = (alpha / (1 - alpha));
arma::mat tX = trans(X);
arma::mat iV_r = arma::inv(V_r);
clock.tick("1");
arma::mat iR_s = arma::inv(Rphi_s);
clock.tock("1");
// Compute posterior updating
arma::mat V_B = a * tX * X + iV_r;
arma::mat V_BW = a * tX;
arma::mat V_WB = trans(V_BW);
arma::mat V_W = iR_s + (a * eye<arma::mat>(n, n));
arma::mat V_star1 = join_horiz(V_B, V_BW);
arma::mat V_star2 = join_horiz(V_WB, V_W);
arma::mat iV_star = join_vert( V_star1, V_star2);
arma::mat V_star = arma::inv(iV_star);
arma::mat M = join_vert( (a * tX * Y) + (iV_r * mu_B) , a * Y );
arma::mat mu_star = V_star * M;
arma::mat aYY = (a * trans(Y) * Y);
arma::mat mbVrmb = (trans(mu_B) * iV_r * mu_B);
arma::mat msVsms = (trans(mu_star) * iV_star * mu_star);
arma::mat Psi_star = Psi + aYY  + mbVrmb - msVsms;
double nu_star = nu + n;
clock.stop("Timing");
// Return results as an R list
return List::create(Named("V_star") = V_star,
Named("mu_star") = mu_star,
Named("Psi_star") = Psi_star,
Named("nu_star") = nu_star,
Named("iRphi_s") = iR_s);
}
// [[Rcpp::export]]
List fit_cpp_MvT_new(const List& data, const List& priors, const arma::mat& coords, const List& hyperpar) {
Rcpp::Clock clock; // mind the headers: //[[Rcpp::depends(RcppClock)]] #include <RcppClock.h> #include <thread>
// Unpack data and priors
arma::mat Y = as<arma::mat>(data["Y"]);
arma::mat X = as<arma::mat>(data["X"]);
arma::mat mu_B = as<arma::mat>(priors["mu_B"]);
arma::mat V_r = as<arma::mat>(priors["V_r"]);
arma::mat Psi = as<arma::mat>(priors["Psi"]);
double nu = as<double>(priors["nu"]);
double alpha = as<double>(hyperpar["alpha"]);
double phi = as<double>(hyperpar["phi"]);
int n = Y.n_rows;
int p = X.n_cols;
arma::mat d_s = arma_dist(coords);
arma::mat Rphi_s = exp(-phi * d_s);
// Precompute some reusable values
double a = (alpha / (1 - alpha));
arma::mat tX = trans(X);
arma::mat iV_r = arma::inv(V_r);
// arma::mat iR_s = arma::inv(Rphi_s);
clock.tick("1");
arma::mat L_r = trimatu(chol(Rphi_s));
arma::mat iR_s = solve(L_r, solve(trans(L_r), eye<arma::mat>(n, n), solve_opts::fast), solve_opts::fast);
clock.tock("1");
// Compute posterior updating
arma::mat V_B = a * tX * X + iV_r;
arma::mat V_BW = a * tX;
arma::mat V_WB = trans(V_BW);
arma::mat V_W = iR_s + (a * eye<arma::mat>(n, n));
arma::mat V_star1 = join_horiz(V_B, V_BW);
arma::mat V_star2 = join_horiz(V_WB, V_W);
arma::mat iV_star = join_vert( V_star1, V_star2);
// arma::mat V_star = arma::inv(iV_star);
// arma::mat M = join_vert( (a * tX * Y) + (iV_r * mu_B) , a * Y );
// arma::mat mu_star = V_star * M;
// arma::mat aYY = (a * trans(Y) * Y);
// arma::mat mbVrmb = (trans(mu_B) * iV_r * mu_B);
// arma::mat msVsms = (trans(mu_star) * iV_star * mu_star);
// arma::mat Psi_star = Psi + aYY  + mbVrmb - msVsms;
// double nu_star = nu + n;
arma::mat iL_v = inv(trimatu(chol(iV_star)));
arma::mat M = join_vert( (a * tX * Y) + (iV_r * mu_B) , a * Y );
arma::mat u = iL_v * M;
arma::mat mu_star = trans(iL_v) * u;
arma::mat V_star = solve(iL_v, solve(trans(iL_v), eye<arma::mat>(n+p, n+p), solve_opts::fast), solve_opts::fast);
arma::mat aYY = (a * trans(Y) * Y);
arma::mat mbVrmb = (trans(mu_B) * iV_r * mu_B);
arma::mat utu = (trans(u) * u);
arma::mat Psi_star = Psi + aYY  + mbVrmb - utu;
double nu_star = nu + n;
clock.stop("Timing");
// Return results as an R list
return List::create(Named("mu_star") = mu_star,
Named("Psi_star") = Psi_star,
Named("nu_star") = nu_star,
Named("V_star") = V_star,
// Named("iRphi_s") = z);
Named("iRphi_s") = iR_s);
}
'
# compile functions
Rcpp::sourceCpp(code = cd)
# testing functions
fun_old <- function() {
fit_cpp_MvT(data = list(Y = Y, X = X),
priors = list(mu_B = matrix(0, nrow = p, ncol = q),
V_r = diag(10, p),
Psi = diag(1, q),
nu = 3),
coords = crd,
hyperpar = list(alpha = alfa, phi = phi))
return(NULL)
}
fun_new <- function() {
fit_cpp_MvT_new(data = list(Y = Y, X = X),
priors = list(mu_B = matrix(0, nrow = p, ncol = q),
V_r = diag(10, p),
Psi = diag(1, q),
nu = 3),
coords = crd,
hyperpar = list(alpha = alfa, phi = phi))
return(NULL)
}
fun_old()
fit_cpp_MvT(data = list(Y = Y, X = X),
priors = list(mu_B = matrix(0, nrow = p, ncol = q),
V_r = diag(10, p),
Psi = diag(1, q),
nu = 3),
coords = crd,
hyperpar = list(alpha = alfa, phi = phi))
Timing
tictoc::tic()
fun_old()
tictoc::toc()
Timing
tictoc::tic()
fun_new()
tictoc::toc()
Timing
tictoc::tic()
fun_old()
tictoc::toc()
Timing
tictoc::tic()
fun_new()
tictoc::toc()
Timing
Timing
fun_old()
Timing
fun_new()
Timing
tictoc::tic()
fun_old()
tictoc::toc()
Timing
tictoc::tic()
fun_new()
tictoc::toc()
Timing
tictoc::tic()
fun_new()
tictoc::toc()
tictoc::tic()
fun_old()
tictoc::toc()
tictoc::tic()
fun_old()
tictoc::toc()
n <- 1000
p <- 2
q <- 2
B <- matrix(c(-0.75, 0.90, 1.85, -1.1), p, q)
sigma2 <- diag(q)
alfa <- 0.8
phi <- 4
set.seed(97)
crd <- matrix(runif((n) * 2), ncol = 2)
X <- cbind(rep(1, n), matrix(runif((p-1)*(n)), ncol = (p-1)))
D <- arma_dist(crd)
Rphi <- exp(-phi * D)
W <- matrix(0, n, q) + mniw::rMNorm(1, Lambda = matrix(0, n, q), SigmaR = Rphi, SigmaC = sigma2)
Y <- X %*% B + W + mniw::rMNorm(1, Lambda = matrix(0, n, q), SigmaR = diag((1/alfa)-1, n), SigmaC = sigma2)
# testing functions
fun_old <- function() {
fit_cpp_MvT(data = list(Y = Y, X = X),
priors = list(mu_B = matrix(0, nrow = p, ncol = q),
V_r = diag(10, p),
Psi = diag(1, q),
nu = 3),
coords = crd,
hyperpar = list(alpha = alfa, phi = phi))
return(NULL)
}
fun_new <- function() {
fit_cpp_MvT_new(data = list(Y = Y, X = X),
priors = list(mu_B = matrix(0, nrow = p, ncol = q),
V_r = diag(10, p),
Psi = diag(1, q),
nu = 3),
coords = crd,
hyperpar = list(alpha = alfa, phi = phi))
return(NULL)
}
tictoc::tic()
fun_old()
tictoc::toc()
Timing
tictoc::tic()
fun_new()
tictoc::toc()
Timing
tictoc::tic()
fun_new()
tictoc::toc()
tictoc::tic()
fun_old()
tictoc::toc()
