arma::mat V_BW = a * tX;
arma::mat V_WB = trans(V_BW);
arma::mat V_W = iR_s + (a * eye<arma::mat>(n, n));
arma::mat V_star1 = join_horiz(V_B, V_BW);
arma::mat V_star2 = join_horiz(V_WB, V_W);
arma::mat iV_star = join_vert( V_star1, V_star2);
// arma::mat V_star = arma::inv(iV_star);
// arma::mat M = join_vert( (a * tX * Y) + (iV_r * mu_B) , a * Y );
// arma::mat mu_star = V_star * M;
// arma::mat aYY = (a * trans(Y) * Y);
// arma::mat mbVrmb = (trans(mu_B) * iV_r * mu_B);
// arma::mat msVsms = (trans(mu_star) * iV_star * mu_star);
// arma::mat Psi_star = Psi + aYY  + mbVrmb - msVsms;
// double nu_star = nu + n;
arma::mat iL_v = inv(trimatu(chol(iV_star)));
arma::mat M = join_vert( (a * tX * Y) + (iV_r * mu_B) , a * Y );
arma::mat u = iL_v * M;
arma::mat mu_star = trans(iL_v) * u;
arma::mat V_star = solve(iL_v, solve(trans(iL_v), eye<arma::mat>(n+p, n+p), solve_opts::fast), solve_opts::fast);
arma::mat aYY = (a * trans(Y) * Y);
arma::mat mbVrmb = (trans(mu_B) * iV_r * mu_B);
arma::mat utu = (trans(u) * u);
arma::mat Psi_star = Psi + aYY  + mbVrmb - utu;
double nu_star = nu + n;
clock.stop("Timing");
// Return results as an R list
return List::create(Named("mu_star") = mu_star,
Named("Psi_star") = Psi_star,
Named("nu_star") = nu_star,
Named("V_star") = V_star,
// Named("iRphi_s") = z);
Named("iRphi_s") = iR_s);
}
'
# compile functions
Rcpp::sourceCpp(code = cd)
# testing functions
fun_old <- function() {
fit_cpp_MvT(data = list(Y = Y, X = X),
priors = list(mu_B = matrix(0, nrow = p, ncol = q),
V_r = diag(10, p),
Psi = diag(1, q),
nu = 3),
coords = crd,
hyperpar = list(alpha = alfa, phi = phi))
return(NULL)
}
fun_new <- function() {
fit_cpp_MvT_new(data = list(Y = Y, X = X),
priors = list(mu_B = matrix(0, nrow = p, ncol = q),
V_r = diag(10, p),
Psi = diag(1, q),
nu = 3),
coords = crd,
hyperpar = list(alpha = alfa, phi = phi))
return(NULL)
}
fun_old()
fit_cpp_MvT(data = list(Y = Y, X = X),
priors = list(mu_B = matrix(0, nrow = p, ncol = q),
V_r = diag(10, p),
Psi = diag(1, q),
nu = 3),
coords = crd,
hyperpar = list(alpha = alfa, phi = phi))
Timing
tictoc::tic()
fun_old()
tictoc::toc()
Timing
tictoc::tic()
fun_new()
tictoc::toc()
Timing
tictoc::tic()
fun_old()
tictoc::toc()
Timing
tictoc::tic()
fun_new()
tictoc::toc()
Timing
Timing
fun_old()
Timing
fun_new()
Timing
tictoc::tic()
fun_old()
tictoc::toc()
Timing
tictoc::tic()
fun_new()
tictoc::toc()
Timing
tictoc::tic()
fun_new()
tictoc::toc()
tictoc::tic()
fun_old()
tictoc::toc()
tictoc::tic()
fun_old()
tictoc::toc()
n <- 1000
p <- 2
q <- 2
B <- matrix(c(-0.75, 0.90, 1.85, -1.1), p, q)
sigma2 <- diag(q)
alfa <- 0.8
phi <- 4
set.seed(97)
crd <- matrix(runif((n) * 2), ncol = 2)
X <- cbind(rep(1, n), matrix(runif((p-1)*(n)), ncol = (p-1)))
D <- arma_dist(crd)
Rphi <- exp(-phi * D)
W <- matrix(0, n, q) + mniw::rMNorm(1, Lambda = matrix(0, n, q), SigmaR = Rphi, SigmaC = sigma2)
Y <- X %*% B + W + mniw::rMNorm(1, Lambda = matrix(0, n, q), SigmaR = diag((1/alfa)-1, n), SigmaC = sigma2)
# testing functions
fun_old <- function() {
fit_cpp_MvT(data = list(Y = Y, X = X),
priors = list(mu_B = matrix(0, nrow = p, ncol = q),
V_r = diag(10, p),
Psi = diag(1, q),
nu = 3),
coords = crd,
hyperpar = list(alpha = alfa, phi = phi))
return(NULL)
}
fun_new <- function() {
fit_cpp_MvT_new(data = list(Y = Y, X = X),
priors = list(mu_B = matrix(0, nrow = p, ncol = q),
V_r = diag(10, p),
Psi = diag(1, q),
nu = 3),
coords = crd,
hyperpar = list(alpha = alfa, phi = phi))
return(NULL)
}
tictoc::tic()
fun_old()
tictoc::toc()
Timing
tictoc::tic()
fun_new()
tictoc::toc()
Timing
tictoc::tic()
fun_new()
tictoc::toc()
tictoc::tic()
fun_old()
tictoc::toc()
usethis::use_vignette("my-vignette")
usethis::use_vignette("tutorial-multivariate")
install.packages("spNNGP")
spBPS::arma_dist(matrix(runif(100), ncol=2))
spBPS::arma_dist(matrix(runif(100), ncol=5))
devtools::document()
usethis::use_vignette("tutorial", "Double Bayesian Predictive Stacking for Spatial Analysis - Tutotial")
library(spBPS)
library(parallel)
library(doParallel)
library(foreach)
library(MBA)
library(classInt)
library(RColorBrewer)
library(sp)
library(fields)
library(bayesplot)
library(parallel)
library(doParallel)
library(foreach)
library(MBA)
library(classInt)
library(RColorBrewer)
library(sp)
library(fields)
library(bayesplot)
# dimensions
n <- 5000
u <- 250
p <- 2
# parameters
B <- c(-0.75, 1.85)
tau2 <- 0.25
sigma2 <- 1
delta <- tau2/sigma2
phi <- 4
set.seed(4-8-15-16-23-42)
# generate sintethic data
crd <- matrix(runif((n+u) * 2), ncol = 2)
X_or <- cbind(rep(1, n+u), matrix(runif((p-1)*(n+u)), ncol = (p-1)))
D <- arma_dist(crd)
Rphi <- exp(-phi * D)
W_or <- matrix(0, n+u) + mniw::rmNorm(1, rep(0, n+u), sigma2*Rphi)
Y_or <- X_or %*% B + W_or + mniw::rmNorm(1, rep(0, n+u), diag(delta*sigma2, n+u))
# sample data
crd_s <- crd[1:n, ]
X <- X_or[1:n, ]
W <- W_or[1:n, ]
Y <- Y_or[1:n, ]
# prediction data
crd_u <- crd[-(1:n), ]
X_u <- X_or[-(1:n), ]
W_u <- W_or[-(1:n), ]
Y_u <- Y_or[-(1:n), ]
# hyperparameters values
delta_seq <- c(0.2, 0.25, 0.3)
phi_seq <- c(3, 4, 5)
# function for the fit loop
fit_loop <- function(i) {
Yi <- data_part$Y_list[[i]]; Xi <- data_part$X_list[[i]]; crd_i <- data_part$crd_list[[i]]
p <- ncol(Xi)
bps <- spBPS::BPS_weights(data = list(Y = Yi, X = Xi),
priors = list(mu_b = matrix(rep(0, p)),
V_b = diag(10, p),
a = 2,
b = 2), coords = crd_i,
hyperpar = list(delta = delta_seq, phi = phi_seq), K = 5)
w_hat <- bps$W
epd <- bps$epd
result <- list(epd, w_hat)
return(result)
}
# function for the pred loop
pred_loop <- function(r) {
ind_s <- subset_ind[r]
Ys <- matrix(data_part$Y_list[[ind_s]]); Xs <- data_part$X_list[[ind_s]]; crds <- data_part$crd_list[[ind_s]]; Ws <- W_list[[ind_s]]
result <- spBPS::BPS_post(data = list(Y = Ys, X = Xs), coords = crds,
X_u = X_u, crd_u = crd_u,
priors = list(mu_b = matrix(rep(0, p)),
V_b = diag(10, p),
a = 2,
b = 2),
hyperpar = list(delta = delta_seq, phi = phi_seq),
W = Ws, R = 1)
return(result)
}
# subsetting data
subset_size <- 500
K <- n/subset_size
data_part <- subset_data(data = list(Y = matrix(Y), X = X, crd = crd_s), K = K)
# number of clusters for parallel implementation
n.core <- parallel::detectCores(logical=F)-1
# list of function
funs_fit <- lsf.str()[which(lsf.str() != "fit_loop")]
# list of function
funs_pred <- lsf.str()[which(lsf.str() != "pred_loop")]
# starting cluster
cl <- makeCluster(n.core)
registerDoParallel(cl)
# timing
tic("total")
library(parallel)
library(doParallel)
library(foreach)
library(tictoc)
library(MBA)
library(classInt)
library(RColorBrewer)
library(sp)
library(fields)
library(bayesplot)
# closing cluster
stopCluster(cl)
# number of clusters for parallel implementation
n.core <- parallel::detectCores(logical=F)-1
# list of function
funs_fit <- lsf.str()[which(lsf.str() != "fit_loop")]
# list of function
funs_pred <- lsf.str()[which(lsf.str() != "pred_loop")]
# starting cluster
cl <- makeCluster(n.core)
registerDoParallel(cl)
# timing
tic("total")
# parallelized subset computation of GP in different cores
tic("fit")
obj_fit <- foreach(i = 1:K, .noexport = funs_fit) %dopar% { fit_loop(i) }
fit_time <- toc()
gc()
# Combination using double BPS
tic("comb")
comb_bps <- BPS_combine(obj_fit, K, 1)
comb_time <- toc()
Wbps <- comb_bps$W
W_list <- comb_bps$W_list
gc()
# parallelized subset computation of GP in different cores
R <- 250
subset_ind <- sample(1:K, R, T, Wbps)
tic("prediction")
predictions <- foreach(r = 1:R, .noexport = funs_pred) %dopar% { pred_loop(r) }
prd_time <- toc()
# timing
tot_time <- toc()
# closing cluster
stopCluster(cl)
gc()
# number of clusters for parallel implementation
n.core <- parallel::detectCores(logical=F)-1
# list of function
funs_fit <- lsf.str()[which(lsf.str() != "fit_loop")]
# list of function
funs_pred <- lsf.str()[which(lsf.str() != "pred_loop")]
# starting cluster
cl <- makeCluster(n.core)
registerDoParallel(cl)
# timing
tic("total")
# parallelized subset computation of GP in different cores
tic("fit")
obj_fit <- foreach(i = 1:K, .noexport = funs_fit) %dopar% { fit_loop(i) }
fit_time <- toc()
gc(verbose = F)
# Combination using double BPS
tic("comb")
comb_bps <- BPS_combine(obj_fit, K, 1)
comb_time <- toc()
Wbps <- comb_bps$W
W_list <- comb_bps$W_list
gc(verbose = F)
# parallelized subset computation of GP in different cores
R <- 250
subset_ind <- sample(1:K, R, T, Wbps)
tic("prediction")
predictions <- foreach(r = 1:R, .noexport = funs_pred) %dopar% { pred_loop(r) }
prd_time <- toc()
# timing
tot_time <- toc()
# closing cluster
stopCluster(cl)
gc(verbose = F)
# statistics computations W
pred_mat_W <- sapply(1:R, function(r){predictions[[r]][[1]]})
post_mean_W <- rowMeans(pred_mat_W)
post_var_W <- apply(pred_mat_W, 1, sd)
post_qnt_W <- apply(pred_mat_W, 1, quantile, c(0.025, 0.975))
# Empirical coverage for W
coverage_W <- mean(W_u >= post_qnt_W[1,] & W_u <= post_qnt_W[2,])
cat("Empirical coverage for Spatial process:", round(coverage_W, 3))
# statistics computations Y
pred_mat_Y <- sapply(1:R, function(r){predictions[[r]][[2]]})
post_mean_Y <- rowMeans(pred_mat_Y)
post_var_Y <- apply(pred_mat_Y, 1, sd)
post_qnt_Y <- apply(pred_mat_Y, 1, quantile, c(0.025, 0.975))
# Empirical coverage for Y
coverage_Y <- mean(Y_u >= post_qnt_Y[1,] & Y_u <= post_qnt_Y[2,])
cat("Empirical coverage for Response:", round(coverage_Y, 3))
(CI_avlen_bps <- mean(post_qnt_Y[2,]-post_qnt_Y[1,]))
# Root Mean Square Prediction Error
(rmspe_W <- sqrt( mean( (W_u - post_mean_W)^2 ) ))
(rmspe_Y <- sqrt( mean( (Y_u - post_mean_Y)^2 ) ))
# statistics computations W
pred_mat_W <- sapply(1:R, function(r){predictions[[r]][[1]]})
post_mean_W <- rowMeans(pred_mat_W)
post_var_W <- apply(pred_mat_W, 1, sd)
post_qnt_W <- apply(pred_mat_W, 1, quantile, c(0.025, 0.975))
# Empirical coverage for W
coverage_W <- mean(W_u >= post_qnt_W[1,] & W_u <= post_qnt_W[2,])
cat("Empirical coverage for Spatial process:", round(coverage_W, 3),"\n")
# statistics computations Y
pred_mat_Y <- sapply(1:R, function(r){predictions[[r]][[2]]})
post_mean_Y <- rowMeans(pred_mat_Y)
post_var_Y <- apply(pred_mat_Y, 1, sd)
post_qnt_Y <- apply(pred_mat_Y, 1, quantile, c(0.025, 0.975))
# Empirical coverage for Y
coverage_Y <- mean(Y_u >= post_qnt_Y[1,] & Y_u <= post_qnt_Y[2,])
cat("Empirical coverage for Response:", round(coverage_Y, 3),"\n")
(CI_avlen_bps <- mean(post_qnt_Y[2,]-post_qnt_Y[1,]))
# Root Mean Square Prediction Error
(rmspe_W <- sqrt( mean( (W_u - post_mean_W)^2 ) ))
(rmspe_Y <- sqrt( mean( (Y_u - post_mean_Y)^2 ) ))
# statistics computations W
pred_mat_W <- sapply(1:R, function(r){predictions[[r]][[1]]})
post_mean_W <- rowMeans(pred_mat_W)
post_var_W <- apply(pred_mat_W, 1, sd)
post_qnt_W <- apply(pred_mat_W, 1, quantile, c(0.025, 0.975))
# Empirical coverage for W
coverage_W <- mean(W_u >= post_qnt_W[1,] & W_u <= post_qnt_W[2,])
cat("Empirical coverage for Spatial process:", round(coverage_W, 3),"\n")
# statistics computations Y
pred_mat_Y <- sapply(1:R, function(r){predictions[[r]][[2]]})
post_mean_Y <- rowMeans(pred_mat_Y)
post_var_Y <- apply(pred_mat_Y, 1, sd)
post_qnt_Y <- apply(pred_mat_Y, 1, quantile, c(0.025, 0.975))
# Empirical coverage for Y
coverage_Y <- mean(Y_u >= post_qnt_Y[1,] & Y_u <= post_qnt_Y[2,])
cat("Empirical coverage for Response:", round(coverage_Y, 3),"\n")
# Root Mean Square Prediction Error
rmspe_W <- sqrt( mean( (W_u - post_mean_W)^2 ) )
rmspe_Y <- sqrt( mean( (Y_u - post_mean_Y)^2 ) )
cat("RMSPE for Spatial process:", rmspe_W, "\n")
cat("RMSPE for Response:", rmspe_Y, "\n")
# true surfaces interpolation
h <- 12
surf.Y <- MBA::mba.surf(cbind(crd_s, Y), no.X = 500, no.Y = 500,
exten = TRUE, sp = TRUE, h = h)$xyz.est
surf.brks <- classIntervals(surf.Y$z, 100, 'pretty')$brks
col.pal <- colorRampPalette(brewer.pal(11,'RdBu')[11:1])
xlim <- c(0, 1)
zlim <- range(surf.Y$z)
# image for plot
iy <- as.image.SpatialGridDataFrame(surf.Y)
# BPS surfaces interpolation
h <- 12
surf.Yp <- MBA::mba.surf(cbind(crd_u, post_mean_Y), no.X = 500, no.Y = 500,
exten = TRUE, sp = TRUE, h = h)$xyz.est
zlimp <- range(surf.Yp$z)
# image for plot
iyp <- as.image.SpatialGridDataFrame(surf.Yp)
# Plotting
par(mfrow = c(1, 2))
plot(crd, type="n", cex=0.5, xlim=xlim, axes=FALSE, ylab="Northing", xlab="Easting",
main="Response")
axis(2, las=1)
axis(1)
image.plot(iy, add=TRUE, col=rev(col.pal(length(surf.brks)-1)), zlim=zlim)
plot(crd, type="n", cex=0.5, xlim=xlim, axes=F, ylab="Northing", xlab="Easting")
title(main="BPS  Prediction (Posterior Mean) for Response")
mtext(side = 3, paste("RMSPE :", round(rmspe_Y, 3)))
axis(2, las=1)
axis(1)
image.plot(iyp, add=TRUE, col=rev(col.pal(length(surf.brks)-1)), zlim=zlimp)
# True spatial process surfaces interpolation
h <- 12
surf.W <- MBA::mba.surf(cbind(crd_s, W), no.X = 500, no.Y = 500,
exten = TRUE, sp = TRUE, h = h)$xyz.est
surf.brks <- classIntervals(surf.W$z, 100, 'pretty')$brks
col.pal <- colorRampPalette(brewer.pal(11,'RdBu')[11:1])
xlim <- c(0, 1)
zlim <- range(surf.W$z)
# image for plot
iw <- as.image.SpatialGridDataFrame(surf.W)
# BPS surfaces interpolation
h <- 12
surf.Wp <- MBA::mba.surf(cbind(crd_u, post_mean_W), no.X = 500, no.Y = 500,
exten = TRUE, sp = TRUE, h = h)$xyz.est
zlimp <- range(surf.Wp$z)
# image for plot
iwp <- as.image.SpatialGridDataFrame(surf.Wp)
# Plotting
par(mfrow = c(1, 2))
plot(crd, type="n", cex=0.5, xlim=xlim, axes=FALSE, ylab="Northing", xlab="Easting",
main="Spatial process")
axis(2, las=1)
axis(1)
image.plot(iw, add=TRUE, col=rev(col.pal(length(surf.brks)-1)), zlim=zlim)
plot(crd, type="n", cex=0.5, xlim=xlim, axes=F, ylab="Northing", xlab="Easting")
title(main="BPS Prediction (Posterior Mean) for Spatial process")
mtext(side = 3, paste("RMSPE :", round(rmspe_Y, 3)))
axis(2, las=1)
axis(1)
image.plot(iwp, add=TRUE, col=rev(col.pal(length(surf.brks)-1)), zlim=zlimp)
par(mfrow = c(1, 1))
# True response surfaces interpolation
h <- 12
surf.Y <- MBA::mba.surf(cbind(crd_s, Y), no.X = 500, no.Y = 500,
exten = TRUE, sp = TRUE, h = h)$xyz.est
surf.brks <- classIntervals(surf.Y$z, 100, 'pretty')$brks
col.pal <- colorRampPalette(brewer.pal(11,'RdBu')[11:1])
xlim <- c(0, 1)
zlim <- range(surf.Y$z)
# image for plot
iy <- as.image.SpatialGridDataFrame(surf.Y)
# BPS surfaces interpolation
h <- 12
surf.Yp <- MBA::mba.surf(cbind(crd_u, post_mean_Y), no.X = 500, no.Y = 500,
exten = TRUE, sp = TRUE, h = h)$xyz.est
zlimp <- range(surf.Yp$z)
# image for plot
iyp <- as.image.SpatialGridDataFrame(surf.Yp)
# Plotting
par(mfrow = c(1, 2))
plot(crd, type="n", cex=0.5, xlim=xlim, axes=FALSE, ylab="Northing", xlab="Easting",
main="Response")
axis(2, las=1)
axis(1)
image.plot(iy, add=TRUE, col=rev(col.pal(length(surf.brks)-1)), zlim=zlim)
plot(crd, type="n", cex=0.5, xlim=xlim, axes=F, ylab="Northing", xlab="Easting")
title(main="BPS  Prediction (Posterior Mean) for Response")
mtext(side = 3, paste("RMSPE :", round(rmspe_Y, 3)))
axis(2, las=1)
axis(1)
image.plot(iyp, add=TRUE, col=rev(col.pal(length(surf.brks)-1)), zlim=zlimp)
par(mfrow = c(1, 1))
8/6
6/4
6*2.54
rmspe_W
rmspe_W
rmspe_Y
7/4
+.5/4
7.5/4
requireNamespace("doParallel", quietly = TRUE)
requireNamespace("doParallel", quietly = F)
!require("doParallel", quietly = TRUE)
require("doParallel", quietly = TRUE)
require("doParallel")
!require("doParallel")
install.packages("rhub")
rhub::
rhub::check(platfom = "debian-gcc-devel")
rhub::rhub_setup()
rhub::rhub_platforms()
rhub::rhub_doctor()
rhub::rhub_check(platforms = c(1))
rhub::rhub_check(platforms = c("linux"))
rhub::rhub_check(platform = "ubuntu-gcc12")
rhub::rhub_check()
